grammar org.absmodel.AbsModel with org.eclipse.xtext.xbase.Xbase

generate absModel "http://www.absmodel.org/AbsModel"

AbsModel:
	moduleSection=AbsModuleSection
	importSection=AbsImportSection?
	declarations+=(
		DataTypeDeclaration | 
		TypeDeclaration |
		FunctionDeclaration | 
		InterfaceDeclaration | 
		ClassDeclaration)*
	'{'
		(statements+=Statement';')*
	'}';

AbsModuleSection:
	'module' QualifiedName ';';

AbsImportSection:
	importDeclarations+=AbsImportDeclaration+;

AbsImportDeclaration:
	'import' (QualifiedName | QualifiedNameWithWildcard) ';';

GenericType:
	'<' TypeParam '>'
;	

TypeParam :
	ValidID (',' ValidID)*	
;

QualifiedTypeParam :
	QualifiedName (',' QualifiedName)*
;

TypeDeclaration :
	'type' name=ValidID '=' data=ValidID (type=GenericType)? ';'
;
	
DataTypeDeclaration :
	'data' name=ValidID (type=GenericType)? ' = ' (conts+=TypeConstructor ('|' const+=TypeConstructor)*) ';'
;

TypeConstructor:
	name=ValidID ('(' type = TypeParam ')')?
;	

FunctionDeclaration :
	'def' returnType=ValidID name=ValidID type=GenericType param=ParamList
	' = ' 
	('builtin' | exp = FunPureExpression )  ';'
;

PureExpression returns Expression :
	PureExpression2  ({Expression.left=current} op = BinaryOp rexp = PureExpression)* 
;

PureExpression2 returns Expression :
	fun = ValidID '(' param += PureExpression (',' param += PureExpression) * ')' |
	op = UnaryOp exp = PureExpression |
	int = INT |
	string = STRING |
	'(' exp = PureExpression ')'
;

FunPureExpression returns Expression :
	exp = PureExpression |
	'case' cexp = FunPureExpression '{' branch += CaseBranch*  '}' 
;

CaseBranch:
	pattern = Pattern '=>' exp = FunPureExpression ';'
;

Pattern :
	' '
;

InterfaceDeclaration:
	'interface' name=ValidID ('extends' type=QualifiedTypeParam)? '{'
		(elements+=MethodSignature ';')*
	'}'
;

ParamList:
	paramList = '(' ( params+=FormalParam (',' params+=FormalParam)* )? ')'
;

MethodSignature:
	type=JvmTypeReference name=ValidID param=ParamList
;

ClassDeclaration:
	'class' name=ValidID param=ParamList? ('implements' type=QualifiedTypeParam)? '{'
		('{' 
			(elements+=SyncStatement';')*
		'}')?
		(fields+=Field';')*
		(operations+=Method)* 
	'}';
	
Field:
	type=QualifiedName name=ValidID
;

Method:
	MethodSignature '{'
		(element+=Statement';')*
		('return' exp=PureExpression ';')?
	'}'
;

FormalParam:
	param=FullJvmFormalParameter
;

Statement:
	stmt = (AsyncStatement | SyncStatement | PureExpression)
;

AsyncStatement returns Expression:
	' '
;

SyncStatement returns Expression:
	' '
;

UnaryOp :
	Neg | Minus
;

ArithBinaryOp :
	Add | Minus | Mult | Div | Mod 
;

EqualityBinaryOp : 
	Leq | Geq | Lt | Gt | Eq | Ne
;

ConditionBinaryOp : 
	And | Or
;

BinaryOp :
	ArithBinaryOp | EqualityBinaryOp | ConditionBinaryOp
;

Neg : '!' ;
Add : '+' ;
Minus : '-' ;
Mult : '*' ;
Div : '/' ;
Mod : '%' ;
Plus : '+' ;
Leq : '<=' ;
Geq : '>=' ;
Lt : '<' ;
Gt : '>' ;
And : '&&' ;
Or : '||' ;
Eq : '==' ;
Ne : '!=' ;
